%% 
clear all
clc
X = sparse(50,50); % 定义元胞的温床
X(21:30,21:30) = (rand(10,10)>.75);% 以25%的概率产生1
p0 = nnz(X); % nnz(X): number of nonezero elements in X, 初代元胞的数量

for t = 1:100 % 迭代100代
    spy(X); % 查看稀疏模式,提前预览开始时的状态
    title(num2str(t));
    drawnow;
    
    n = size(X,1);
    p = [1 1:n-1];
    q = [2:n n];
    % 这里p表示行或者列的索引，p(i)表示第i行或第i列的前一列或者前一行，即p表示上，左这两个方向
    % 这里q表示行或者列的索引，q(j)表示第j行或第j列的后一列或者后一行，即q表示下，右这两个方向
    % 这里将上下左右四个基础方向又抽象为两个方向，而p,q中对第一行(列)以及最后一行(列)的重复
    % 说明在边界时的处理策略，即第一行(列)的上左为它本身，最后一行(列)的下右为它本身
    % 这在后续的计算中实际上是有问题的，但是鉴于这里边界本身都是0元素，所以在迭代中并不会出现问题
    % 而且在lifex的程序中，还定义了扩展宇宙的方法来防止出现边界
    % 所以如果在有边界时，下面的计算元胞下一时刻的存活状态的方式是有一些错误的，但是错误不大，容易修改
    Y = X(:,p)+X(:,q)+X(p,:)+X(q,:)+X(p,p)+X(q,q)+X(p,q)+X(q,p);% Y(i,j)表示该元素8邻居的生存状态(0-8)
    % X(:,p): 所有行的前一列，相当于是每一列的前一列;
    % X(:,q): 所有行的后一列，相当于是每一列的后一列
    % X(p,:): 每行的前一行的所有列，相当于是每一行的前一行
    % X(q,:): 每行的后一行的所有列，相当于是每一行的后一行
    % X(p,p): 在行方向的前一行，列方向的前一列，即当前元素(行列)的左上元素
    % X(q,q): 在行方向的后一行，列方向的后一列，即当前元素(行列)的右下元素
    % X(p,q)和X(q,p)以此类推
    X = ((X==1)&(Y==2))|(Y==3);
end
 p100 = nnz(X); % 100代之后的存活元胞数
 fprintf('初代:%5d 第100代:%5d 100代/初代:%8.3f\n',p0,p100,p100/p0);
    
    
    
    
    
    
    
    
    
    
    
    
    